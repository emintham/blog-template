---
// src/pages/admin/create-post.astro
import BaseLayout from '../../layouts/BaseLayout.astro';
import PostForm from '../../components/admin/PostForm.astro'; // Import the new form component
import { SITE_TITLE } from '../../siteConfig';

// --- DEV Mode Check ---
if (!import.meta.env.DEV) {
  return new Response(null, { status: 404, statusText: 'Not Found' });
}

const pageTitle = `Create New Post (DEV) - ${SITE_TITLE}`;
// AUTHOR_NAME is handled by the API route directly from siteConfig.ts,
// so no need to pass it via define:vars for form population.
---

<BaseLayout title={pageTitle}>
  <div class="page-detail-header" style="margin-bottom: 1.5rem;">
    <h1>Create New Post</h1>
  </div>

  {/* The main form tag remains here.
      The PostForm component renders the fieldsets and inputs inside this form. */}
  <form id="createPostForm" class="post-form"> {/* Added .post-form class if PostForm.astro styles rely on it */}
    <PostForm /> {/* Using the reusable form component for a new post (no postData prop passed) */}
    <button type="submit" class="button-primary" style="margin-top: 1rem;">Save New Post</button>
  </form>

  {/* Feedback area for API response */}
  <div id="formFeedback" style="margin-top: 1.5rem; padding: 1rem; border-radius: 4px; display: none;">
    <p id="feedbackMessage"></p>
    <a id="viewPostLink" href="#" style="display:none; margin-top: 0.5rem;" class="button-edit">View Post</a>
  </div>
</BaseLayout>

<script>
  // Client-side script for handling form submission to the API
  const form = document.getElementById('createPostForm') as HTMLFormElement | null;
  const formFeedback = document.getElementById('formFeedback') as HTMLDivElement | null;
  const feedbackMessage = document.getElementById('feedbackMessage') as HTMLParagraphElement | null;
  const viewPostLink = document.getElementById('viewPostLink') as HTMLAnchorElement | null;
  // The script within PostForm.astro handles its internal DOM manipulations (like toggling bookNoteFields)

  if (form) {
    form.addEventListener('submit', async (e) => {
      e.preventDefault();
      const submitButton = form.querySelector('button[type="submit"]') as HTMLButtonElement | null;

      if (submitButton) {
        submitButton.disabled = true;
        submitButton.textContent = 'Saving...';
      }
      if (formFeedback) formFeedback.style.display = 'none';
      if (viewPostLink) viewPostLink.style.display = 'none';

      const formData = new FormData(form);
      const data: Record<string, any> = {};
      formData.forEach((value, key) => {
        // Handle cases where a key might appear multiple times (e.g., multi-select, though not used here)
        // For this form, simple assignment is fine.
        if (data[key] === undefined) {
            data[key] = value;
        } else {
            if (!Array.isArray(data[key])) {
                data[key] = [data[key]];
            }
            data[key].push(value);
        }
      });

      // Convert checkbox 'on' to boolean for draft status
      data.draft = formData.has('draft');

      // Convert bookCover fields into a nested object if present
      if (data.bookCoverImageName || data.bookCoverAlt) {
        data.bookCover = {
            imageName: data.bookCoverImageName || '',
            alt: data.bookCoverAlt || ''
        };
        delete data.bookCoverImageName; // Clean up flat properties
        delete data.bookCoverAlt;
      }


      try {
        const response = await fetch('/api/create-post-handler', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data),
        });

        const result = await response.json();

        if (feedbackMessage && formFeedback) { // Ensure elements exist
            if (response.ok) {
                feedbackMessage.textContent = result.message + (result.filename ? ` (Filename: ${result.filename})` : '');
                formFeedback.style.backgroundColor = 'var(--color-note-paper)'; // Or a success color
                formFeedback.style.border = '1px solid var(--color-accent)';
                if (result.path && viewPostLink) {
                    viewPostLink.href = result.path;
                    viewPostLink.style.display = 'inline-block';
                }
                form.reset(); // Optionally reset the form
                // Re-set default draft state and postType after reset
                (document.getElementById('draft') as HTMLInputElement).checked = true;
                const postTypeSelect = document.getElementById('postType') as HTMLSelectElement;
                if (postTypeSelect) postTypeSelect.value = 'standard';
                // Trigger display logic in PostForm if needed, though reset should handle values
                const formBookNoteFields = document.getElementById('formBookNoteFields') as HTMLFieldSetElement | null;
                if(formBookNoteFields && postTypeSelect.value !== 'bookNote') {
                    formBookNoteFields.style.display = 'none';
                }


            } else {
                feedbackMessage.textContent = `Error: ${result.message || response.statusText}`;
                formFeedback.style.backgroundColor = '#ffdddd'; // Error color
                formFeedback.style.border = '1px solid red';
            }
        }
      } catch (error) {
        console.error('Network or other error:', error);
        if (feedbackMessage && formFeedback) {
            feedbackMessage.textContent = 'Network error or failed to connect to the API.';
            formFeedback.style.backgroundColor = '#ffdddd';
            formFeedback.style.border = '1px solid red';
        }
      } finally {
        if (formFeedback) {
            formFeedback.style.display = 'block';
            formFeedback.scrollIntoView({ behavior: 'smooth' });
        }
        if (submitButton) {
            submitButton.disabled = false;
            submitButton.textContent = 'Save New Post';
        }
      }
    });
  }
</script>
